// ----------------------------------------------------------
// This Source Code Form is subject to the terms of the
// Mozilla Public License, v.2.0. If a copy of the MPL
// was not distributed with this file, You can obtain one
// at http://mozilla.org/MPL/2.0/.
// ----------------------------------------------------------
// Codebase: https://github.com/ArKuznetsov/irac/
// ----------------------------------------------------------

Перем Владелец;
Перем Элементы;            // - ОбъектыКластера   - элементы коллекции объектов кластера

Перем МоментАктуальности;    // - Число    - последний момент получения информации от сервиса RAS
Перем ПериодОбновления;      // - Число    - период обновления информации от сервиса RAS

Процедура ПриСозданииОбъекта(ВладелецЭлементов)

	Элементы = Неопределено;

	Владелец = ВладелецЭлементов;

	ПериодОбновления = Служебный.ПериодОбновленияДанныхОбъекта(ВладелецЭлементов);
	МоментАктуальности = 0;

КонецПроцедуры // ПриСозданииОбъекта()

// Процедура заполняет список элементов из переданного массива
//
// Параметры:
//   МассивЭлементов     - Массив        - элементы, которые будут добавлены
//
Процедура Заполнить(МассивЭлементов) Экспорт

	Если ТипЗнч(Элементы) = Тип("Массив") Тогда
		Элементы.Очистить();
	КонецЕсли;
	
	Элементы = Новый Массив();

	Для Каждого ТекЭлемент Из МассивЭлементов Цикл
		Элементы.Добавить(ТекЭлемент);
	КонецЦикла;

КонецПроцедуры // Заполнить()

// Процедура добавляет элемент в список
//
// Параметры:
//   Элемент     - Произвольный        - добавляемый элемент
//
Процедура Добавить(Элемент) Экспорт

	Элементы.Добавить(Элемент);

КонецПроцедуры // Добавить()

// Функция признак необходимости обновления данных
//
// Параметры:
//   РежимОбновления           - Число        - 1 - обновить данные принудительно (вызов RAC)
//                                              0 - обновить данные только по таймеру
//                                             -1 - не обновлять данные
//
// Возвращаемое значение:
//    Булево - Истина - требуется обновитьданные
//
Функция ТребуетсяОбновление(РежимОбновления = 0) Экспорт

	Если РежимОбновления = Перечисления.РежимыОбновленияДанных.НеОбновлять Тогда
		Возврат Ложь;
	ИначеЕсли РежимОбновления = Перечисления.РежимыОбновленияДанных.Принудительно Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат (Элементы = Неопределено
		ИЛИ (ПериодОбновления < (ТекущаяУниверсальнаяДатаВМиллисекундах() - МоментАктуальности)));

КонецФункции // ТребуетсяОбновление()

// Функция возвращает описание параметров объекта
//
// Возвращаемое значение:
//    КомандыОбъекта - описание параметров объекта,
//
Функция ПараметрыОбъекта() Экспорт

	Возврат Владелец.ПараметрыОбъекта();

КонецФункции // ПараметрыОбъекта()

// Функция возвращает список объектов кластера
//
// Параметры:
//   Отбор                    - Структура    - Структура отбора объектов (<поле>:<значение>)
//   РежимОбновления          - Число        - 1 - обновить данные принудительно (вызов RAC)
//                                             0 - обновить данные только по таймеру
//                                            -1 - не обновлять данные
//   ЭлементыКакСоответствия  - Булево,      - Истина - элементы результата будут преобразованы в соответствия
//                              Строка         с именами свойств в качестве ключей
//                                             <Имя поля> - элементы результата будут преобразованы в соответствия
//                                             со значением указанного поля в качестве ключей ("Имя"|"ИмяРАК")
//                                             Ложь - (по умолчанию) элементы будут возвращены как есть
//
// Возвращаемое значение:
//    Массив - список объектов кластера 1С
//
Функция Список(Знач Отбор = Неопределено
			 , Знач РежимОбновления = 0
			 , Знач ЭлементыКакСоответствия = Ложь) Экспорт

	Владелец.ОбновитьДанные(РежимОбновления);

	Результат = Служебный.ПолучитьЭлементыИзМассиваСоответствий(Элементы, Отбор);

	ИмяПоляКлюча = "Имя";

	Если ТипЗнч(ЭлементыКакСоответствия) = Тип("Строка") Тогда
		ИмяПоляКлюча = ЭлементыКакСоответствия;
		ЭлементыКакСоответствия = Истина;
	КонецЕсли;

	Если ЭлементыКакСоответствия Тогда
		ПоляЭлемента = Владелец.ПараметрыОбъекта().ОписаниеСвойств(ИмяПоляКлюча);
		Результат = Служебный.МассивОбъектовВМассивСоответствий(Результат, ПоляЭлемента);
	КонецЕсли;

	Возврат Результат;

КонецФункции // Список()

// Функция возвращает список объектов кластера
//
// Параметры:
//   ПоляИерархии             - Строка,      - имена полей для построения иерархии списка объектов,
//                              Массив         разделенные "," или массив имен полей
//   РежимОбновления          - Число        - 1 - обновить данные принудительно (вызов RAC)
//                                             0 - обновить данные только по таймеру
//                                            -1 - не обновлять данные
//   ЭлементыКакСоответствия  - Булево,      - Истина - элементы результата будут преобразованы в соответствия
//                              Строка         с именами свойств в качестве ключей
//                                             <Имя поля> - элементы результата будут преобразованы в соответствия
//                                             со значением указанного поля в качестве ключей ("Имя"|"ИмяРАК")
//                                             Ложь - (по умолчанию) элементы будут возвращены как есть
//
// Возвращаемое значение:
//    Соответствие - список объектов кластера 1С
//        <имя поля объекта>    - Массив(Соответствие), Соответствие    - список объектов кластера или следующий уровень
//
Функция ИерархическийСписок(Знач ПоляИерархии
                          , Знач РежимОбновления = 0
                          , Знач ЭлементыКакСоответствия = Ложь) Экспорт

	Владелец.ОбновитьДанные(РежимОбновления);

	ЭлементыДляОбработки = Элементы;

	ИменаПолейКлюча = Новый Массив();
	ИменаПолейКлюча.Добавить("Имя");
	ИменаПолейКлюча.Добавить("ИмяРАК");
	
	Если ТипЗнч(ЭлементыКакСоответствия) = Тип("Строка") Тогда
		Если ИменаПолейКлюча[1] = ЭлементыКакСоответствия Тогда
			ИменаПолейКлюча[1] = ИменаПолейКлюча[0];
			ИменаПолейКлюча[0] = ЭлементыКакСоответствия;
		КонецЕсли;
		ЭлементыКакСоответствия = Истина;
	КонецЕсли;

	ПоляЭлемента0 = Владелец.ПараметрыОбъекта().ОписаниеСвойств(ИменаПолейКлюча[0]);
	ПоляЭлемента1 = Владелец.ПараметрыОбъекта().ОписаниеСвойств(ИменаПолейКлюча[1]);

	Если ТипЗнч(ПоляИерархии) = Тип("Строка") Тогда
		ПоляИерархии = СтрРазделить(ПоляИерархии, ",", Ложь);
	КонецЕсли;

	Для й = 0 По ПоляИерархии.ВГраница() Цикл
		ОписаниеПоля = ПоляЭлемента0.Получить(ПоляИерархии[й]);
		Если ОписаниеПоля = Неопределено Тогда
			ОписаниеПоля = ПоляЭлемента1.Получить(ПоляИерархии[й]);
		КонецЕсли;
		ПоляИерархии[й] = ОписаниеПоля[ИменаПолейКлюча[0]];
	КонецЦикла;

	Если ЭлементыКакСоответствия Тогда
		ЭлементыДляОбработки = Служебный.МассивОбъектовВМассивСоответствий(Элементы, ПоляЭлемента0);
	КонецЕсли;

	Возврат Служебный.ИерархическоеПредставлениеМассиваСоответствий(ЭлементыДляОбработки, ПоляИерархии);

КонецФункции // ИерархическийСписок()

// Функция возвращает количество объектов в списке
//
// Возвращаемое значение:
//    Число - количество объектов в списке
//
Функция Количество() Экспорт

	Владелец.ОбновитьДанные();

	Если Элементы = Неопределено Тогда
		Возврат 0;
	КонецЕсли;
	
	Возврат Элементы.Количество();

КонецФункции // Количество()

// Процедура устанавливает значение периода обновления
//
// Параметры:
//   НовыйПериодОбновления     - Число        - новый период обновления
//
Процедура УстановитьПериодОбновления(НовыйПериодОбновления) Экспорт

	ПериодОбновления = НовыйПериодОбновления;

КонецПроцедуры // УстановитьПериодОбновления()

// Процедура устанавливает новое значение момента актуальности данных
//
Процедура УстановитьАктуальность() Экспорт

	МоментАктуальности = ТекущаяУниверсальнаяДатаВМиллисекундах();

КонецПроцедуры // УстановитьАктуальность()
